!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Accept	src/csapp.c	/^int Accept(int s, struct sockaddr *addr, socklen_t *addrlen) $/;"	f
Alarm	src/csapp.c	/^unsigned int Alarm(unsigned int seconds) {$/;"	f
Bind	src/csapp.c	/^void Bind(int sockfd, struct sockaddr *my_addr, int addrlen) $/;"	f
CFG_FILE	include/IO-server.h	5;"	d
CLIENT	Makefile	/^CLIENT := csapp.o echoclient.o$/;"	m
Calloc	src/csapp.c	/^void *Calloc(size_t nmemb, size_t size) $/;"	f
Close	src/csapp.c	/^void Close(int fd) $/;"	f
Connect	src/csapp.c	/^void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen) $/;"	f
DEF_MODE	include/csapp.h	30;"	d
DEF_UMASK	include/csapp.h	31;"	d
Dup2	src/csapp.c	/^int Dup2(int fd1, int fd2) $/;"	f
EncodeFix	include/Encode.h	/^class EncodeFix {$/;"	c
Execve	src/csapp.c	/^void Execve(const char *filename, char *const argv[], char *const envp[]) $/;"	f
Extract	include/IO-server.h	/^  string Extract(string templine) { \/\/ 提取字符串中的key，value$/;"	f	class:IO_server
Fclose	src/csapp.c	/^void Fclose(FILE *fp) $/;"	f
Fdopen	src/csapp.c	/^FILE *Fdopen(int fd, const char *type) $/;"	f
Fgets	src/csapp.c	/^char *Fgets(char *ptr, int n, FILE *stream) $/;"	f
FindNextSeparators	test/Encode.cpp	/^bool FindNextSeparators(const string& in, int& length, int& cur_pos) {  \/\/ 找到下一个'\\n'的位置$/;"	f
Flushall	include/IO-server.h	/^  void Flushall() { \/\/ 清空leveldb数据库$/;"	f	class:IO_server
Fopen	src/csapp.c	/^FILE *Fopen(const char *filename, const char *mode) $/;"	f
Fork	src/csapp.c	/^pid_t Fork(void) $/;"	f
Fputs	src/csapp.c	/^void Fputs(const char *ptr, FILE *stream) $/;"	f
Fread	src/csapp.c	/^size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream) $/;"	f
Free	src/csapp.c	/^void Free(void *ptr) $/;"	f
Fstat	src/csapp.c	/^void Fstat(int fd, struct stat *buf) $/;"	f
Fwrite	src/csapp.c	/^void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) $/;"	f
Gethostbyaddr	src/csapp.c	/^struct hostent *Gethostbyaddr(const char *addr, int len, int type) $/;"	f
Gethostbyname	src/csapp.c	/^struct hostent *Gethostbyname(const char *name) $/;"	f
Getpgrp	src/csapp.c	/^pid_t Getpgrp(void) {$/;"	f
INFTIM	src/echoserveri.cpp	15;"	d	file:
IO_server	include/IO-server.h	/^class IO_server {$/;"	c
JudgeOrder	test/Encode.cpp	/^bool JudgeOrder(const string& in, int& cur_pos) { \/\/ 判断是不是以$开头的参数语句$/;"	f
Judgestring	test/Encode.cpp	/^bool Judgestring(const string& in, int& cur_pos) {  \/\/ 判断是不是以*开头的序列化语句$/;"	f
Kill	src/csapp.c	/^void Kill(pid_t pid, int signum) $/;"	f
LISTENQ	include/csapp.h	57;"	d
LISTENQ	src/echoserveri.cpp	16;"	d	file:
Listen	src/csapp.c	/^void Listen(int s, int backlog) $/;"	f
Lseek	src/csapp.c	/^off_t Lseek(int fildes, off_t offset, int whence) $/;"	f
MAXBUF	include/csapp.h	56;"	d
MAXLINE	include/csapp.h	55;"	d
Malloc	src/csapp.c	/^void *Malloc(size_t size) $/;"	f
Mmap	src/csapp.c	/^void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset) $/;"	f
Munmap	src/csapp.c	/^void Munmap(void *start, size_t length) $/;"	f
NTHREADS	src/echoservert.c	3;"	d	file:
OPEN_MAX	src/echoserveri.cpp	13;"	d	file:
Open	src/csapp.c	/^int Open(const char *pathname, int flags, mode_t mode) $/;"	f
Open_clientfd	src/csapp.c	/^int Open_clientfd(char *hostname, int port) $/;"	f
Open_listenfd	src/csapp.c	/^int Open_listenfd(int port) $/;"	f
P	src/csapp.c	/^void P(sem_t *sem) $/;"	f
Pause	src/csapp.c	/^void Pause() $/;"	f
Pthread_cancel	src/csapp.c	/^void Pthread_cancel(pthread_t tid) {$/;"	f
Pthread_create	src/csapp.c	/^void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp, $/;"	f
Pthread_detach	src/csapp.c	/^void Pthread_detach(pthread_t tid) {$/;"	f
Pthread_exit	src/csapp.c	/^void Pthread_exit(void *retval) {$/;"	f
Pthread_join	src/csapp.c	/^void Pthread_join(pthread_t tid, void **thread_return) {$/;"	f
Pthread_once	src/csapp.c	/^void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {$/;"	f
Pthread_self	src/csapp.c	/^pthread_t Pthread_self(void) {$/;"	f
RIO_BUFSIZE	include/csapp.h	41;"	d
Read	src/csapp.c	/^ssize_t Read(int fd, void *buf, size_t count) $/;"	f
Realloc	src/csapp.c	/^void *Realloc(void *ptr, size_t size) $/;"	f
Rio_readinitb	src/csapp.c	/^void Rio_readinitb(rio_t *rp, int fd)$/;"	f
Rio_readlineb	src/csapp.c	/^ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) $/;"	f
Rio_readn	src/csapp.c	/^ssize_t Rio_readn(int fd, void *ptr, size_t nbytes) $/;"	f
Rio_readnb	src/csapp.c	/^ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n) $/;"	f
Rio_writen	src/csapp.c	/^void Rio_writen(int fd, void *usrbuf, size_t n) $/;"	f
SA	include/csapp.h	/^typedef struct sockaddr SA;$/;"	t	typeref:struct:sockaddr
SBUFSIZE	src/echoservert.c	4;"	d	file:
SERVER	Makefile	/^SERVER := echoserveri.o echo.o csapp.o sbuf.o$/;"	m
SERV_PORT	src/echoserveri.cpp	14;"	d	file:
SOURCE	Makefile	/^SOURCE := $(wildcard src\/*.c src\/*.cpp)$/;"	m
Select	src/csapp.c	/^int Select(int  n, fd_set *readfds, fd_set *writefds,$/;"	f
Sem_init	src/csapp.c	/^void Sem_init(sem_t *sem, int pshared, unsigned int value) $/;"	f
Setpgid	src/csapp.c	/^void Setpgid(pid_t pid, pid_t pgid) {$/;"	f
Setsockopt	src/csapp.c	/^void Setsockopt(int s, int level, int optname, const void *optval, int optlen) $/;"	f
Sigaddset	src/csapp.c	/^void Sigaddset(sigset_t *set, int signum)$/;"	f
Sigdelset	src/csapp.c	/^void Sigdelset(sigset_t *set, int signum)$/;"	f
Sigemptyset	src/csapp.c	/^void Sigemptyset(sigset_t *set)$/;"	f
Sigfillset	src/csapp.c	/^void Sigfillset(sigset_t *set)$/;"	f
Sigismember	src/csapp.c	/^int Sigismember(const sigset_t *set, int signum)$/;"	f
Signal	src/csapp.c	/^handler_t *Signal(int signum, handler_t *handler) $/;"	f
Sigprocmask	src/csapp.c	/^void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)$/;"	f
Sleep	src/csapp.c	/^unsigned int Sleep(unsigned int secs) $/;"	f
Socket	src/csapp.c	/^int Socket(int domain, int type, int protocol) $/;"	f
Split	test/Encode.cpp	/^void Split(const string& in, std::vector<std::string>* out, int& cur_pos, int& size) { \/\/ 使key, value, 指令装到vector里面$/;"	f
Stat	src/csapp.c	/^void Stat(const char *filename, struct stat *buf) $/;"	f
V	src/csapp.c	/^void V(sem_t *sem) $/;"	f
Wait	src/csapp.c	/^pid_t Wait(int *status) $/;"	f
Waitpid	src/csapp.c	/^pid_t Waitpid(pid_t pid, int *iptr, int options) $/;"	f
Write	src/csapp.c	/^ssize_t Write(int fd, const void *buf, size_t count) $/;"	f
__CSAPP_H__	include/csapp.h	3;"	d
__SBUF_H__	include/sbuf.h	2;"	d
app_error	src/csapp.c	/^void app_error(char *msg) \/* Application error *\/$/;"	f
buf	include/sbuf.h	/^  int *buf;$/;"	m	struct:__anon1
dbpath	src/echo.cpp	/^string dbpath = "leveldb.db";$/;"	v
dns_error	src/csapp.c	/^void dns_error(char *msg) \/* DNS-style error *\/$/;"	f
echo	src/echo.cpp	/^bool echo(char* buf) {$/;"	f
flushall	include/IO-server.h	/^  string flushall() {  \/\/ 使用文件清空$/;"	f	class:IO_server
front	include/sbuf.h	/^  int front;$/;"	m	struct:__anon1
get	include/IO-server.h	/^  string get(string Key) { \/\/ get函数参数指令，key$/;"	f	class:IO_server
getCharLength	include/Encode.h	/^  int getCharLength(char *p) { \/\/ 获取从客户端发来的字符串长度$/;"	f	class:EncodeFix
getOrder	include/Encode.h	/^  string getOrder(char *buf, int index, int maxsize) { \/\/ 获取字符串长度指令, key, value$/;"	f	class:EncodeFix
getWord	include/Encode.h	/^  string getWord(string word) { \/\/ 将字符串末尾加上换行$/;"	f	class:EncodeFix
handler_t	include/csapp.h	/^typedef void handler_t(int);$/;"	t
items	include/sbuf.h	/^  sem_t items;$/;"	m	struct:__anon1
main	src/echoclient.cpp	/^int main(int argc, char **argv) {$/;"	f
main	src/echoserveri.cpp	/^int main(int argc, char **argv) {$/;"	f
main	src/echoservert.c	/^int main(int argc, char **argv) {$/;"	f
main	test/Encode.cpp	/^int main(int argc, char*argv[]) {$/;"	f
main	test/test.cpp	/^int main(int argc, char*argv[]) {$/;"	f
mutex	include/sbuf.h	/^  sem_t mutex;$/;"	m	struct:__anon1
n	include/sbuf.h	/^  int n;$/;"	m	struct:__anon1
open_clientfd	src/csapp.c	/^int open_clientfd(char *hostname, int port) $/;"	f
open_listenfd	src/csapp.c	/^int open_listenfd(int port) $/;"	f
options	src/echo.cpp	/^leveldb::Options options;$/;"	v
orderTolower	include/Encode.h	/^  void orderTolower(string order) { \/\/ 指令小写化$/;"	f	class:EncodeFix
paramtertotal	test/Encode.cpp	/^bool paramtertotal(const string& in, int& cur_pos, int& size) { \/\/ 使字符串指令变成int类型的size$/;"	f
position	include/IO-server.h	/^    int position;$/;"	m	class:IO_server
posix_error	src/csapp.c	/^void posix_error(int code, char *msg) \/* Posix-style error *\/$/;"	f
rear	include/sbuf.h	/^  int rear;$/;"	m	struct:__anon1
rio_buf	include/csapp.h	/^	char rio_buf[RIO_BUFSIZE]; \/* Internal buffer *\/$/;"	m	struct:__anon2
rio_bufptr	include/csapp.h	/^	char *rio_bufptr;          \/* Next unread byte in internal buf *\/$/;"	m	struct:__anon2
rio_cnt	include/csapp.h	/^	int rio_cnt;               \/* Unread bytes in internal buf *\/$/;"	m	struct:__anon2
rio_fd	include/csapp.h	/^	int rio_fd;                \/* Descriptor for this internal buf *\/$/;"	m	struct:__anon2
rio_read	src/csapp.c	/^static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)$/;"	f	file:
rio_readinitb	src/csapp.c	/^void rio_readinitb(rio_t *rp, int fd) $/;"	f
rio_readlineb	src/csapp.c	/^ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) $/;"	f
rio_readn	src/csapp.c	/^ssize_t rio_readn(int fd, void *usrbuf, size_t n) $/;"	f
rio_readnb	src/csapp.c	/^ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) $/;"	f
rio_t	include/csapp.h	/^} rio_t;$/;"	t	typeref:struct:__anon2
rio_writen	src/csapp.c	/^ssize_t rio_writen(int fd, void *usrbuf, size_t n) $/;"	f
sbuf	src/echoservert.c	/^sbuf_t sbuf;$/;"	v
sbuf_deinit	src/sbuf.c	/^void sbuf_deinit(sbuf_t *sp) {$/;"	f
sbuf_init	src/sbuf.c	/^void sbuf_init(sbuf_t *sp, int n) {$/;"	f
sbuf_insert	src/sbuf.c	/^void sbuf_insert(sbuf_t *sp, int item) {$/;"	f
sbuf_remove	src/sbuf.c	/^int sbuf_remove(sbuf_t *sp) {$/;"	f
sbuf_t	include/sbuf.h	/^} sbuf_t;$/;"	t	typeref:struct:__anon1
set	include/IO-server.h	/^  void set(string order, string key, string value) {  \/\/ set函数参数指令,key,value$/;"	f	class:IO_server
slots	include/sbuf.h	/^  sem_t slots;$/;"	m	struct:__anon1
sqlSplice	include/Encode.h	/^  string sqlSplice(string sql, string word, int flag) { \/\/ 拼接字符串$/;"	f	class:EncodeFix
thread	src/echoservert.c	/^void *thread(void *vargp) {$/;"	f
unix_error	src/csapp.c	/^void unix_error(char *msg) \/* Unix-style error *\/$/;"	f
